# cs3110-project

TODO:
- make a varlog to hold variables

Members: Adith (ar729), Eliot (ess239), Omar (ob47)
Meeting times: 

# Proposal
# Core idea: 
Programmable Calculator with more advanced TI-Basic 83-like language
# Key features: 
- LBL and GOTO in the language
- Solver
- User defined functions (separate from language)
- Graphing (through GRAPH command)
- REPL for normal calculator evaluations
# In-depth description: 
We plan on making a programmable graphing calculator with three main sets of features.  First, there’ll be the base calculator REPL: we run basic commands and calculation strings with order of operations

Functions: more like extended operators, similar to OCaml functions, exist separate of the scripts generated by the programming language. Just deal with numbers so they could be used in replacement for operators in things like graphs without risk of error: I/O.

Scripts: amalgams of commands for more complex purposes.  Can have multiple side effects.

# Roadmap: 
- MS1: REPL
- Satisfactory: implement base calculator REPL
- Good: order of operations, parentheses
- Excellent: implement graphing
- MS2: Functions/REPL++
- Satisfactory: Built-in complex commands (definite derivatives, definite integrals, etc)
- Good: implement solver
- Excellent: User defined operators
- MS3: Programming language
- Satisfactory: base commands (DISP, INPUT, etc)
- Good: IF THEN ELSE statements,variables, perhaps loops
- Excellent: LBL, GOTO

# Preliminary sketch description: 
Each of these is a module

We haven’t totally figured out exactly how we want syntax to look like for any of these features (and which would be more robust for us to implement). The examples give possible ways of stating things

REPL: 
Commands inputted into the REPL will be parsed from infix notation to postfix notation for ease of computation, and expressions will be pushed to a stack for calculation. Our implementation will have a REPL module taking care of the PEMDAS operations through that stack implementation in which all standard mathematical operators (+, -, / *, exponent, log, etc) will be represented

We will specify the evaluation of expressions in this or similar such way:

EVAL { 64/(8*8+0) }
// evaluation is 1

Solver:
We will have the ability to solve a system of linear equations, or (at least one solution for) a single polynomial equation of one variable. 

This module will likely have its own parsing functions that will take the coefficient values in front of each variable and store them into a matrix, where matrix operations will be used to find the vector solution if it exists.

An operation could look something like this:

SOLVE { x^2 + 8x + 16 = 0 }
//x = 4, -4





We will also implement definite Integrals/Derivatives. For example:

INTEGRAL {
Interval: [0, 10]
Function: 6x
}
// Integral is 100 from [0,10]


DERIV 3 of { 6X }
//Derivative of the function at 3 is 6



Functions:
The functions module will likely have its own parser as well to tease out what is a valid parameter input and to take the user-defined function body (if it satisfies PEMDAS) and translate it into something OCAML can use. If a user defines a function, it could look something like this on terminal:

fun(W,X,Y,Z) AVG = <(W+X+Y+Z)/4 >

In which case every time the user called @AVG(1,2,3,4) at any point while they are running the program, the number 2.5 will be returned.By the way, the @ symbol is us telling our code to make function call on the following function name. Functions within functions won’t be supported

Language/interpreter: 
This will be our most challenging module to implement, as now we are implementing basically a primitive computer language in our terminal.
The language will have whitespace as delineating individual commands and syntactically separate parts of code, and a defined “END” keyword to end every expression, ex “IF … THEN … ELSE … END”, “VAR … = … END”, etc.  It will not have object oriented, or even modular functionality, using “GOTO” and “LBL” to move through the script.

We will take in a text file containing code in our language and read it into a dictionary, splitting on whitespace.  The keys will be the number of the command, in order from the top of the file, with the first command having key 0.  The values will be the actual code: commands, variables, and others.  When processing the language, commands will be pushed to a call stack, while an index variable will hold our location in the code itself.



Graphing: 
We will use a third party application for the grapher. The one we will use is xQuartz or something similar, such as ocamlgraph, which windows users need to install. In order to communicate between xQuartz and OCaml, we must install the OCaml Graphics module “opam install graphics”

Graphing could look something like this (we will likely rely on our functions module to help with ONLY 2d graphing):

GRAPH { fun(X) LINEAR =  <x + 7>}

Testing:
Testing will be done for the corresponding tasks that we have finished in the timeline. In line with test-driven development, we will, for example, test whether our REPL stack works and can handle the order of operations by testing different mathematical PEMDAS expressions. Then we will attempt to test graphing by plotting different types of graphs. 
